<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FlowBoard</title>
    
    <!-- --- PWA & Mobile Settings --- -->
    <!-- Android / Chrome -->
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- iOS / Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FlowBoard">
    
    <!-- Icons -->
    <link rel="icon" type="image/jpeg" href="https://live.staticflickr.com/65535/54707259194_d205400eeb_w.jpg">
    <link rel="apple-touch-icon" href="https://live.staticflickr.com/65535/54707259194_d205400eeb_w.jpg">
    
    <!-- Link to Manifest File -->
    <link rel="manifest" href="manifest.json">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts (Sarabun for Thai) -->
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        body { 
            font-family: 'Sarabun', sans-serif; 
            overscroll-behavior: none; 
        }
        .canvas-container {
            touch-action: none; 
        }
        .custom-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.344.0",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js",
        "firebase/auth": "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-50 h-screen w-screen overflow-hidden">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Plus, StickyNote, Type, Image as ImageIcon, Link as LinkIcon, 
            Move, ZoomIn, ZoomOut, Maximize, X, Trash2, CheckCircle, 
            Clock, AlertCircle, ArrowLeft, Book, MoreVertical, Edit2, 
            FolderOpen, PenTool, Undo, Redo, Calendar as CalendarIcon, 
            ChevronLeft, ChevronRight, Filter, LogOut, User, Loader2, Mail,
            DownloadCloud, Smartphone
        } from 'lucide-react';

        import { initializeApp } from 'firebase/app';
        import { getAuth, signInWithPopup, GoogleAuthProvider, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'firebase/auth';
        import { getFirestore, collection, doc, setDoc, addDoc, deleteDoc, onSnapshot, serverTimestamp, getDoc, Timestamp } from 'firebase/firestore';

        const firebaseConfig = {
            apiKey: "AIzaSyChLR9pMmY1QCgD2HjJ0GjTGS5mx6tG0N8",
            authDomain: "lnwlawyer.firebaseapp.com",
            projectId: "lnwlawyer",
            storageBucket: "lnwlawyer.firebasestorage.app",
            messagingSenderId: "105328800542",
            appId: "1:105328800542:web:7be90ebd1937e98a548f0f",
            measurementId: "G-RN817Q6CXT"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const rawAppId = typeof __app_id !== 'undefined' ? __app_id : 'flowboard-v1';
        const appId = rawAppId.replace(/[^a-zA-Z0-9_-]/g, '_');

        const getSvgPathFromStroke = (stroke) => {
            if (!stroke || !stroke.length) return "";
            return `M ${stroke.map(p => `${p.x},${p.y}`).join(" L ")}`;
        };
        const getTouchDistance = (touches) => Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);

        const AuthScreen = ({ onLogin }) => {
            const [isLogin, setIsLogin] = useState(true);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);
            const [deferredPrompt, setDeferredPrompt] = useState(null);

            useEffect(() => {
                const handler = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                };
                window.addEventListener('beforeinstallprompt', handler);
                return () => window.removeEventListener('beforeinstallprompt', handler);
            }, []);

            const handleInstallClick = async () => {
                if (!deferredPrompt) return;
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') {
                    setDeferredPrompt(null);
                }
            };

            const handleGoogleLogin = async () => { setLoading(true); setError(''); try { await signInWithPopup(auth, new GoogleAuthProvider()); } catch (err) { setError(err.message); setLoading(false); } };
            const handleEmailAuth = async (e) => { e.preventDefault(); setLoading(true); setError(''); try { if (isLogin) await signInWithEmailAndPassword(auth, email, password); else await createUserWithEmailAndPassword(auth, email, password); } catch (err) { setError(err.message); setLoading(false); } };

            return (
                <div className="h-full w-full bg-gray-50 flex items-center justify-center p-4 font-sans overflow-y-auto custom-scroll">
                    <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-md border border-gray-100 my-auto">
                        <div className="text-center mb-8"><div className="w-16 h-16 bg-blue-100 rounded-2xl flex items-center justify-center mx-auto mb-4 text-blue-600"><Move className="w-10 h-10" /></div><h1 className="text-2xl font-bold text-gray-800">ยินดีต้อนรับสู่ FlowBoard</h1><p className="text-gray-500 mt-2">พื้นที่สำหรับความคิดสร้างสรรค์ของคุณ</p></div>
                        {error && <div className="bg-red-50 text-red-600 p-3 rounded-lg mb-4 text-sm flex items-center gap-2"><AlertCircle className="w-4 h-4" /> {error}</div>}
                        <form onSubmit={handleEmailAuth} className="space-y-4">
                            <div><label className="block text-sm font-medium text-gray-700 mb-1">อีเมล</label><input type="email" required value={email} onChange={(e) => setEmail(e.target.value)} className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-blue-500 outline-none transition-all" placeholder="name@example.com" /></div>
                            <div><label className="block text-sm font-medium text-gray-700 mb-1">รหัสผ่าน</label><input type="password" required value={password} onChange={(e) => setPassword(e.target.value)} className="w-full p-3 border rounded-xl focus:ring-2 focus:ring-blue-500 outline-none transition-all" placeholder="••••••••" /></div>
                            <button type="submit" disabled={loading} className="w-full bg-blue-600 text-white py-3 rounded-xl font-bold hover:bg-blue-700 transition-colors flex items-center justify-center gap-2">{loading ? <Loader2 className="w-5 h-5 animate-spin" /> : (isLogin ? 'เข้าสู่ระบบ' : 'สมัครสมาชิก')}</button>
                        </form>
                        <div className="relative my-6"><div className="absolute inset-0 flex items-center"><div className="w-full border-t border-gray-200"></div></div><div className="relative flex justify-center text-sm"><span className="px-2 bg-white text-gray-500">หรือ</span></div></div>
                        <button onClick={handleGoogleLogin} disabled={loading} className="w-full bg-white border border-gray-300 text-gray-700 py-3 rounded-xl font-bold hover:bg-gray-50 transition-colors flex items-center justify-center gap-2"><span className="text-xl font-bold text-blue-600">G</span> ดำเนินการต่อด้วย Google</button>
                        
                        {deferredPrompt && (
                            <button onClick={handleInstallClick} className="w-full mt-4 bg-indigo-50 text-indigo-700 border border-indigo-100 py-3 rounded-xl font-bold hover:bg-indigo-100 transition-colors flex items-center justify-center gap-2">
                                <Smartphone className="w-5 h-5" /> ติดตั้งแอป FlowBoard
                            </button>
                        )}

                        <p className="mt-6 text-center text-sm text-gray-600">{isLogin ? "ยังไม่มีบัญชี?" : "มีบัญชีอยู่แล้ว?"}<button onClick={() => setIsLogin(!isLogin)} className="ml-1 text-blue-600 font-bold hover:underline">{isLogin ? "สมัครสมาชิก" : "เข้าสู่ระบบ"}</button></p>
                    </div>
                </div>
            );
        };

        const ConnectionLayer = ({ connections, items }) => {
            return (
                <svg className="absolute top-0 left-0 w-full h-full pointer-events-none z-0 overflow-visible">
                    <defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" /></marker></defs>
                    {connections.map((conn) => {
                        const fromItem = items.find((i) => i.id === conn.from); const toItem = items.find((i) => i.id === conn.to);
                        if (!fromItem || !toItem) return null;
                        const startX = fromItem.x + fromItem.width / 2; const startY = fromItem.y + fromItem.height / 2;
                        const endX = toItem.x + toItem.width / 2; const endY = toItem.y + toItem.height / 2;
                        return (<g key={conn.id}><line x1={startX} y1={startY} x2={endX} y2={endY} stroke="#94a3b8" strokeWidth="2" markerEnd="url(#arrowhead)" strokeDasharray={conn.type === 'dashed' ? "5,5" : "0"} /></g>);
                    })}
                </svg>
            );
        };

        const CanvasItem = ({ item, isSelected, onPointerDown, onSelect, onDoubleClick }) => {
            const getBorderColor = () => (isSelected ? 'ring-2 ring-blue-500 shadow-xl' : (item.type === 'drawing' ? '' : 'shadow-md hover:shadow-lg border-gray-200'));
            const getStatusIcon = (status) => { switch (status) { case 'done': return <CheckCircle className="w-4 h-4 text-green-500" />; case 'doing': return <Clock className="w-4 h-4 text-amber-500" />; default: return <AlertCircle className="w-4 h-4 text-gray-400" />; } };
            const baseStyle = { transform: `translate(${item.x}px, ${item.y}px)`, width: `${item.width}px`, height: item.type === 'note' ? `${item.width}px` : `${item.height}px` };
            
            if (item.type === 'drawing') {
                return (
                    <div className={`absolute cursor-grab active:cursor-grabbing select-none ${isSelected ? 'z-20' : 'z-10'}`} style={{...baseStyle, pointerEvents: 'all'}} onPointerDown={(e) => onPointerDown(e, item)} onClick={(e) => { e.stopPropagation(); onSelect(item.id); }} onDoubleClick={() => onDoubleClick(item)}>
                        <div className={`w-full h-full ${isSelected ? 'ring-2 ring-blue-500 ring-offset-4 rounded-sm' : ''}`}><svg width="100%" height="100%" viewBox={`0 0 ${item.width} ${item.height}`} className="overflow-visible"><path d={getSvgPathFromStroke(item.points)} stroke={item.color || "#000"} strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round" /></svg></div>
                    </div>
                );
            }
            if (item.type === 'note') {
                return (
                    <div className={`absolute cursor-grab active:cursor-grabbing p-4 transition-shadow select-none ${item.color} ${isSelected ? 'ring-2 ring-blue-500 z-20' : 'z-10'}`} style={baseStyle} onPointerDown={(e) => onPointerDown(e, item)} onClick={(e) => { e.stopPropagation(); onSelect(item.id); }} onDoubleClick={() => onDoubleClick(item)}>
                        <div className="font-handwriting text-lg leading-tight text-gray-800 break-words h-full overflow-hidden pointer-events-none">{item.content || "โน้ตใหม่..."}</div>
                    </div>
                );
            }
            return (
                <div className={`absolute bg-white rounded-lg border flex flex-col cursor-grab active:cursor-grabbing transition-all select-none ${getBorderColor()} ${isSelected ? 'z-20' : 'z-10'}`} style={{...baseStyle, height: 'auto', minHeight: `${item.height}px`}} onPointerDown={(e) => onPointerDown(e, item)} onClick={(e) => { e.stopPropagation(); onSelect(item.id); }} onDoubleClick={() => onDoubleClick(item)}>
                    <div className={`h-2 w-full rounded-t-lg ${item.color || 'bg-gray-200'}`} />
                    <div className="p-3 flex flex-col gap-2 pointer-events-none">
                        <div className="flex justify-between items-start"><h3 className="font-bold text-gray-800 leading-snug">{item.title || "ชื่องานใหม่"}</h3>{getStatusIcon(item.status)}</div>
                        <p className="text-xs text-gray-500 line-clamp-3">{item.content || "คำอธิบายงาน..."}</p>
                        <div className="mt-2 pt-2 border-t border-gray-100 flex justify-between items-center"><span className="text-[10px] px-2 py-0.5 bg-gray-100 rounded text-gray-500 font-mono">ID-{item.id.toString().slice(-4)}</span>{item.assignee && (<div className="w-5 h-5 rounded-full bg-blue-100 text-blue-600 text-[10px] flex items-center justify-center font-bold">{item.assignee[0]}</div>)}</div>
                    </div>
                </div>
            );
        };

        const MiniMap = ({ items, viewport, setViewport }) => {
            const bounds = useMemo(() => {
                if (items.length === 0) return { minX: 0, maxX: 2000, minY: 0, maxY: 1000 };
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                items.forEach(i => { minX = Math.min(minX, i.x); maxX = Math.max(maxX, i.x + i.width); minY = Math.min(minY, i.y); maxY = Math.max(maxY, i.y + i.height); });
                return { minX: minX - 500, maxX: maxX + 500, minY: minY - 500, maxY: maxY + 500 };
            }, [items]);
            const scale = Math.min(160 / (bounds.maxX - bounds.minX || 1), 100 / (bounds.maxY - bounds.minY || 1));
            return (
                <div className="fixed bottom-4 right-4 w-40 h-24 bg-white border border-gray-300 shadow-lg rounded-md overflow-hidden opacity-90 hidden sm:block pointer-events-none">
                    <div className="relative w-full h-full bg-gray-50">
                        {items.map(item => (<div key={item.id} className={`absolute ${item.type === 'note' ? item.color.replace('bg-', 'bg-') : item.type === 'drawing' ? 'bg-transparent border border-gray-400' : 'bg-gray-400'}`} style={{ left: (item.x - bounds.minX) * scale, top: (item.y - bounds.minY) * scale, width: Math.max(2, item.width * scale), height: Math.max(2, (item.type === 'note' ? item.width : item.height) * scale), borderRadius: '1px' }} />))}
                        <div className="absolute border-2 border-red-500 bg-red-500/10" style={{ left: (-viewport.x - bounds.minX) * scale, top: (-viewport.y - bounds.minY) * scale, width: (window.innerWidth / viewport.scale) * scale, height: (window.innerHeight / viewport.scale) * scale }} />
                    </div>
                </div>
            );
        };

        const EditModal = ({ item, isOpen, onClose, onSave, onDelete }) => {
            const [data, setData] = useState({ ...item });
            useEffect(() => { if(item) setData({ ...item }); }, [item]);
            if (!isOpen || !item) return null;
            if (item.type === 'drawing') {
                return (
                    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm p-6 text-center animate-in fade-in zoom-in">
                            <h3 className="text-lg font-bold mb-4">จัดการรูปวาด</h3>
                            <div className="flex gap-4 justify-center"><button onClick={() => { onDelete(item.id); onClose(); }} className="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 flex items-center gap-2"><Trash2 className="w-4 h-4" /> ลบ</button><button onClick={onClose} className="bg-gray-200 text-gray-700 px-4 py-2 rounded hover:bg-gray-300">ปิด</button></div>
                        </div>
                    </div>
                );
            }
            return (
                <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col max-h-[90vh] animate-in fade-in zoom-in">
                        <div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="text-lg font-bold flex items-center gap-2 text-gray-700">{item.type === 'note' ? <StickyNote /> : <CheckCircle />} แก้ไขรายละเอียด</h2><button onClick={onClose}><X className="w-5 h-5" /></button></div>
                        <div className="p-6 overflow-y-auto space-y-4">
                            {item.type !== 'note' && (<div><label className="block text-sm font-medium text-gray-700">หัวข้อ</label><input value={data.title || ''} onChange={(e) => setData({...data, title: e.target.value})} className="w-full p-2 border rounded-md" /></div>)}
                            <div><label className="block text-sm font-medium text-gray-700">เนื้อหา</label><textarea value={data.content || ''} onChange={(e) => setData({...data, content: e.target.value})} rows={6} className="w-full p-2 border rounded-md" /></div>
                            <div className="flex gap-4"><div className="flex-1"><label className="block text-sm font-medium text-gray-700">สี</label><div className="flex gap-2">{['bg-yellow-200', 'bg-blue-200', 'bg-green-200', 'bg-red-200', 'bg-white'].map(color => (<button key={color} onClick={() => setData({...data, color})} className={`w-6 h-6 rounded-full border border-gray-300 ${color} ${data.color === color ? 'ring-2 ring-gray-400' : ''}`} />))}</div></div>{item.type !== 'note' && (<div className="flex-1"><label className="block text-sm font-medium text-gray-700">สถานะ</label><select value={data.status || 'todo'} onChange={(e) => setData({...data, status: e.target.value})} className="w-full p-2 border rounded-md"><option value="todo">To Do</option><option value="doing">Doing</option><option value="done">Done</option></select></div>)}</div>
                        </div>
                        <div className="p-4 border-t bg-gray-50 flex justify-between"><button onClick={() => { onDelete(item.id); onClose(); }} className="text-red-500 flex items-center gap-1"><Trash2 className="w-4 h-4" /> ลบ</button><button onClick={() => { onSave(data); onClose(); }} className="bg-blue-600 text-white px-6 py-2 rounded-md">บันทึก</button></div>
                    </div>
                </div>
            );
        };

        const ConfirmModal = ({ isOpen, title, message, onConfirm, onCancel }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-[60] flex items-center justify-center p-4" onClick={onCancel}>
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm p-6 text-center animate-in fade-in zoom-in" onClick={e => e.stopPropagation()}>
                        <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4"><AlertCircle className="w-6 h-6 text-red-600" /></div>
                        <h3 className="text-lg font-bold text-gray-800 mb-2">{title}</h3>
                        <p className="text-gray-500 text-sm mb-6">{message}</p>
                        <div className="flex gap-3 justify-center"><button onClick={onCancel} className="px-4 py-2 bg-gray-100 rounded-lg">ยกเลิก</button><button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white rounded-lg">ยืนยัน</button></div>
                    </div>
                </div>
            );
        };

        const CalendarWidget = ({ notebooks, selectedDate, onSelectDate }) => {
            const [currentDate, setCurrentDate] = useState(new Date());
            const daysInMonth = (date) => new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            const firstDayOfMonth = (date) => new Date(date.getFullYear(), date.getMonth(), 1).getDay();
            const prevMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1));
            const nextMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1));
            const totalDays = daysInMonth(currentDate); const startDay = firstDayOfMonth(currentDate);
            const hasActivity = (day) => { const checkDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), day).toDateString(); return notebooks.some(nb => nb.updatedAt && new Date(nb.updatedAt).toDateString() === checkDate); };
            const isSelected = (day) => { if (!selectedDate) return false; return selectedDate.toDateString() === new Date(currentDate.getFullYear(), currentDate.getMonth(), day).toDateString(); };
            const months = ["ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค."];
            return (
                <div className="bg-white rounded-xl shadow-sm border border-gray-100 p-4">
                    <div className="flex justify-between items-center mb-4"><h3 className="font-bold text-gray-700">{months[currentDate.getMonth()]} {currentDate.getFullYear() + 543}</h3><div className="flex gap-1"><button onClick={prevMonth} className="p-1"><ChevronLeft className="w-5 h-5" /></button><button onClick={nextMonth} className="p-1"><ChevronRight className="w-5 h-5" /></button></div></div>
                    <div className="grid grid-cols-7 gap-1 text-center mb-2">{['อา', 'จ', 'อ', 'พ', 'พฤ', 'ศ', 'ส'].map(d => (<div key={d} className="text-xs text-gray-400">{d}</div>))}</div>
                    <div className="grid grid-cols-7 gap-1">
                        {[...Array(startDay)].map((_, i) => <div key={`empty-${i}`} />)}
                        {[...Array(totalDays)].map((_, i) => { const day = i + 1; const active = hasActivity(day); const selected = isSelected(day); return (<button key={day} onClick={() => onSelectDate(new Date(currentDate.getFullYear(), currentDate.getMonth(), day))} className={`h-8 w-8 rounded-full flex items-center justify-center text-sm relative ${selected ? 'bg-blue-600 text-white' : 'hover:bg-gray-100'} ${!selected && active ? 'font-bold' : ''}`}>{day}{active && !selected && <div className="absolute bottom-1 w-1 h-1 bg-blue-500 rounded-full"></div>}</button>); })}
                    </div>
                    {selectedDate && <button onClick={() => onSelectDate(null)} className="w-full mt-4 text-xs text-blue-600 flex justify-center gap-1"><X className="w-3 h-3" /> ล้างตัวกรอง</button>}
                </div>
            );
        };

        const Dashboard = ({ user, notebooks, onSelectNotebook, onCreateNotebook, onDeleteNotebook, onRenameNotebook, selectedDate, onSelectDate, onMigrate, hasLocalData }) => {
            const [isCreating, setIsCreating] = useState(false);
            const [newBookName, setNewBookName] = useState('');
            const getInitialDate = () => (selectedDate || new Date()).toISOString().split('T')[0];
            const [newBookDate, setNewBookDate] = useState(getInitialDate());
            const [editingId, setEditingId] = useState(null);
            const [editName, setEditName] = useState('');
            const [deleteId, setDeleteId] = useState(null);
            
            useEffect(() => { if (isCreating) setNewBookDate(getInitialDate()); }, [isCreating, selectedDate]);
            const handleCreate = (e) => { e.preventDefault(); if (newBookName.trim()) { onCreateNotebook(newBookName, newBookDate ? new Date(newBookDate) : new Date()); setNewBookName(''); setIsCreating(false); } };
            const handleRename = (id) => { if (editName.trim()) onRenameNotebook(id, editName); setEditingId(null); };
            const filteredNotebooks = selectedDate ? notebooks.filter(nb => nb.updatedAt && new Date(nb.updatedAt).toDateString() === selectedDate.toDateString()) : notebooks;

            return (
                <div className="h-full w-full bg-gray-50 overflow-y-auto custom-scroll p-4 md:p-8 font-sans">
                    <div className="max-w-7xl mx-auto pb-20">
                        <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
                            <div><h1 className="text-2xl font-bold text-gray-800 flex items-center gap-2"><Book className="w-7 h-7 text-blue-600" /> ห้องสมุดของฉัน</h1></div>
                            <div className="flex items-center gap-2 w-full md:w-auto">
                                {hasLocalData && <button onClick={onMigrate} className="flex items-center gap-2 bg-amber-100 text-amber-700 px-3 py-1.5 rounded-full text-sm font-medium border border-amber-200 animate-pulse hover:animate-none"><DownloadCloud className="w-4 h-4" /> กู้คืนข้อมูลเดิม</button>}
                                <div className="flex items-center gap-2 bg-white px-3 py-1.5 rounded-full shadow-sm border border-gray-100 flex-1 md:flex-initial">{user.photoURL ? (<img src={user.photoURL} className="w-6 h-6 rounded-full" />) : (<User className="w-5 h-5 text-gray-500" />)}<span className="text-sm font-medium text-gray-700 truncate max-w-[100px]">{user.displayName || user.email}</span></div>
                                <button onClick={() => signOut(auth)} className="p-2 bg-white hover:bg-gray-100 rounded-full text-gray-600 border border-gray-200"><LogOut className="w-5 h-5" /></button>
                                <button onClick={() => setIsCreating(true)} className="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md flex items-center gap-2 text-sm font-medium whitespace-nowrap"><Plus className="w-4 h-4" /> สร้างสมุด</button>
                            </div>
                        </div>
                        <div className="flex flex-col lg:flex-row gap-6 items-start">
                            <div className="w-full lg:w-80 flex-shrink-0 space-y-6 lg:sticky lg:top-4">
                                <CalendarWidget notebooks={notebooks} selectedDate={selectedDate} onSelectDate={onSelectDate} />
                            </div>
                            <div className="flex-1 w-full">
                                {isCreating && (
                                    <form onSubmit={handleCreate} className="mb-6 p-6 bg-white rounded-xl shadow-lg border border-blue-100 animate-in fade-in slide-in-from-top-4">
                                        <h3 className="font-bold text-gray-700 mb-4">สร้างสมุดเล่มใหม่</h3>
                                        <div className="space-y-4">
                                            <div><label className="block text-sm font-medium text-gray-700 mb-1">ชื่อสมุด</label><input autoFocus type="text" value={newBookName} onChange={(e) => setNewBookName(e.target.value)} className="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                                            <div><label className="block text-sm font-medium text-gray-700 mb-1">วันที่สร้าง</label><div className="flex items-center gap-2"><CalendarIcon className="w-5 h-5 text-gray-500" /><input type="date" value={newBookDate} onChange={(e) => setNewBookDate(e.target.value)} className="p-2 border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none flex-1" /></div></div>
                                            <div className="flex gap-2 pt-2"><button type="submit" className="bg-blue-600 text-white px-6 py-2 rounded-lg flex-1">สร้าง</button><button type="button" onClick={() => setIsCreating(false)} className="bg-gray-200 text-gray-700 px-6 py-2 rounded-lg">ยกเลิก</button></div>
                                        </div>
                                    </form>
                                )}
                                {filteredNotebooks.length === 0 ? (
                                    <div className="flex flex-col items-center justify-center py-16 bg-white rounded-xl border border-dashed border-gray-300 text-gray-400"><FolderOpen className="w-16 h-16 mb-4 opacity-50" /><p>ไม่พบสมุดโน้ต</p></div>
                                ) : (
                                    <div className="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-3 gap-4">
                                        {filteredNotebooks.map(book => (
                                            <div key={book.id} onClick={() => onSelectNotebook(book.id)} className="group relative bg-white rounded-xl p-5 shadow-sm hover:shadow-xl hover:-translate-y-1 transition-all cursor-pointer border border-gray-100 flex flex-col justify-between h-40">
                                                <div className="absolute top-0 left-0 w-1.5 h-full bg-blue-500 rounded-l-xl opacity-80" />
                                                <div>
                                                    <div className="flex justify-between items-start mb-2 pl-3">
                                                        <div className="p-2 bg-blue-50 rounded-lg text-blue-600"><Book className="w-5 h-5" /></div>
                                                        <div className="flex gap-1" onClick={e => e.stopPropagation()}>
                                                            <button onClick={() => { setEditingId(book.id); setEditName(book.name); }} className="p-1.5 hover:bg-gray-100 rounded text-gray-500"><Edit2 className="w-4 h-4" /></button>
                                                            <button onClick={() => setDeleteId(book.id)} className="p-1.5 hover:bg-red-50 rounded text-red-500"><Trash2 className="w-4 h-4" /></button>
                                                        </div>
                                                    </div>
                                                    <div className="pl-3">
                                                        {editingId === book.id ? (<input autoFocus value={editName} onChange={(e) => setEditName(e.target.value)} onBlur={() => handleRename(book.id)} onKeyDown={(e) => e.key === 'Enter' && handleRename(book.id)} onClick={(e) => e.stopPropagation()} className="w-full p-1 border rounded font-bold" />) : (<h3 className="font-bold text-gray-800 line-clamp-1">{book.name}</h3>)}
                                                    </div>
                                                </div>
                                                <div className="pl-3 mt-auto pt-3 border-t border-gray-50 flex items-center gap-2 text-xs text-gray-400"><Clock className="w-3 h-3" /><span>{book.updatedAt ? new Date(book.updatedAt).toLocaleDateString('th-TH') : '-'}</span></div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                        <ConfirmModal isOpen={!!deleteId} title="ยืนยันการลบ" message="ลบสมุดนี้?" onConfirm={() => { onDeleteNotebook(deleteId); setDeleteId(null); }} onCancel={() => setDeleteId(null)} />
                    </div>
                </div>
            );
        };

        const App = () => {
            const [user, setUser] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            const [view, setView] = useState('dashboard');
            const [activeNotebookId, setActiveNotebookId] = useState(null);
            const [notebooks, setNotebooks] = useState([]);
            const [selectedDate, setSelectedDate] = useState(null);
            const [items, setItems] = useState([]);
            const [connections, setConnections] = useState([]);
            const [history, setHistory] = useState([]);
            const [historyStep, setHistoryStep] = useState(-1);
            const [viewport, setViewport] = useState({ x: 0, y: 0, scale: 1 });
            const [selectedId, setSelectedId] = useState(null);
            const [interactionMode, setInteractionMode] = useState('select');
            const [dragging, setDragging] = useState(null);
            const [editingItem, setEditingItem] = useState(null);
            const [connectStartId, setConnectStartId] = useState(null);
            const [currentStroke, setCurrentStroke] = useState(null);
            const [pinchDistance, setPinchDistance] = useState(null);
            const [hasLocalData, setHasLocalData] = useState(false);
            const containerRef = useRef(null);

            useEffect(() => { const unsubscribe = onAuthStateChanged(auth, (u) => { setUser(u); setAuthLoading(false); }); return () => unsubscribe(); }, []);

            useEffect(() => {
                const localBooks = localStorage.getItem('flowboard-notebooks');
                const localItems = localStorage.getItem('flowboard-items');
                if (localBooks || localItems) setHasLocalData(true);
            }, []);

            useEffect(() => {
                if (!user) { setNotebooks([]); return; }
                const notebooksRef = collection(db, 'artifacts', appId, 'users', user.uid, 'notebooks');
                const unsubscribe = onSnapshot(notebooksRef, (snapshot) => {
                    const books = snapshot.docs.map(doc => { const data = doc.data(); return { id: doc.id, ...data, createdAt: data.createdAt?.toMillis ? data.createdAt.toMillis() : Date.now(), updatedAt: data.updatedAt?.toMillis ? data.updatedAt.toMillis() : Date.now(), }; });
                    books.sort((a, b) => b.updatedAt - a.updatedAt); setNotebooks(books);
                });
                return () => unsubscribe();
            }, [user]);

            useEffect(() => {
                if (!user || !activeNotebookId) { setItems([]); setConnections([]); return; }
                const canvasDocRef = doc(db, 'artifacts', appId, 'users', user.uid, 'canvas_data', activeNotebookId);
                const unsubscribe = onSnapshot(canvasDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data(); setItems(data.items || []); setConnections(data.connections || []);
                        if (history.length === 0) { setHistory([{ items: data.items || [], connections: data.connections || [] }]); setHistoryStep(0); }
                    } else { setItems([]); setConnections([]); setHistory([]); setHistoryStep(-1); }
                    setView('canvas');
                });
                return () => unsubscribe();
            }, [user, activeNotebookId]);

            // Immediate Save for critical actions
            const saveCanvasData = async (newItems, newConnections) => {
                if (!user || !activeNotebookId) return;
                try {
                    const canvasDocRef = doc(db, 'artifacts', appId, 'users', user.uid, 'canvas_data', activeNotebookId);
                    await setDoc(canvasDocRef, { items: newItems, connections: newConnections, updatedAt: serverTimestamp() });
                } catch (err) { console.error("Save error:", err); }
            };

            const saveTimeoutRef = useRef(null);
            // Minimal debounce mainly for high-freq drag updates to avoid rate limit, but rely on immediate save for edits
            // Actually, for edits, we call saveCanvasData immediately now. 
            // We can remove this generic effect to avoid race condition or make it very selective.
            // Removing generic auto-save on state change to prevent overwrite. We will rely on explicit calls.

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedId && !editingItem) deleteItem(selectedId);
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { if (e.shiftKey) redo(); else undo(); e.preventDefault(); }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { redo(); e.preventDefault(); }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedId, editingItem, history, historyStep]);

            const pushToHistory = (newItems, newConnections) => {
                const newHistory = history.slice(0, historyStep + 1); newHistory.push({ items: newItems, connections: newConnections });
                if (newHistory.length > 50) newHistory.shift(); setHistory(newHistory); setHistoryStep(newHistory.length - 1);
            };
            const undo = () => { if (historyStep > 0) { const prev = history[historyStep - 1]; setItems(prev.items); setConnections(prev.connections); setHistoryStep(historyStep - 1); saveCanvasData(prev.items, prev.connections); } };
            const redo = () => { if (historyStep < history.length - 1) { const next = history[historyStep + 1]; setItems(next.items); setConnections(next.connections); setHistoryStep(historyStep + 1); saveCanvasData(next.items, next.connections); } };

            const handleCreateNotebook = async (name, customDate) => {
                if (!user) return;
                try {
                    const timestamp = customDate ? Timestamp.fromDate(customDate) : serverTimestamp();
                    const newBook = { name, createdAt: timestamp, updatedAt: timestamp };
                    await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'notebooks'), newBook);
                } catch (err) { console.error("Error creating notebook:", err); }
            };
            const handleDeleteNotebook = async (id) => {
                if (!user) return;
                try { await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'notebooks', id)); await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'canvas_data', id)); if (activeNotebookId === id) { setActiveNotebookId(null); setView('dashboard'); } } catch (err) { console.error("Error deleting:", err); }
            };
            const handleRenameNotebook = async (id, newName) => {
                if (!user) return;
                try { await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'notebooks', id), { name: newName }, { merge: true }); } catch (err) { console.error("Error renaming:", err); }
            };

            const handleMigrateData = async () => {
                if (!user) return;
                try {
                    const localBooks = JSON.parse(localStorage.getItem('flowboard-notebooks') || '[]');
                    for (const nb of localBooks) {
                        const newBook = { name: nb.name, createdAt: serverTimestamp(), updatedAt: serverTimestamp() };
                        const docRef = await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'notebooks'), newBook);
                        const localItems = localStorage.getItem(`flowboard-data-${nb.id}-items`);
                        const localConns = localStorage.getItem(`flowboard-data-${nb.id}-conns`);
                        if (localItems) {
                            await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'canvas_data', docRef.id), {
                                items: JSON.parse(localItems), connections: localConns ? JSON.parse(localConns) : [], updatedAt: serverTimestamp()
                            });
                        }
                    }
                    const v1Items = localStorage.getItem('flowboard-items');
                    if (v1Items && localBooks.length === 0) {
                        const newBook = { name: "สมุดที่กู้คืน (Legacy)", createdAt: serverTimestamp(), updatedAt: serverTimestamp() };
                        const docRef = await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'notebooks'), newBook);
                        const v1Conns = localStorage.getItem('flowboard-connections');
                        await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'canvas_data', docRef.id), {
                            items: JSON.parse(v1Items), connections: v1Conns ? JSON.parse(v1Conns) : [], updatedAt: serverTimestamp()
                        });
                    }
                    alert("กู้คืนข้อมูลเรียบร้อยแล้ว!");
                    setHasLocalData(false);
                    // localStorage.clear(); // Optional
                } catch (err) { console.error("Migration error:", err); alert("เกิดข้อผิดพลาดในการกู้คืนข้อมูล"); }
            };

            const getCanvasCoordinates = (cx, cy) => ({ x: (cx - viewport.x) / viewport.scale, y: (cy - viewport.y) / viewport.scale });
            const getTouchDistance = (touches) => Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);

            const handlePointerDown = (e) => {
                if (e.target === containerRef.current || e.target.tagName === 'SVG' || interactionMode === 'draw') {
                    if (interactionMode === 'draw') {
                        const { x, y } = getCanvasCoordinates(e.clientX, e.clientY);
                        setCurrentStroke([{x, y}]); setSelectedId(null); e.target.setPointerCapture(e.pointerId); return;
                    }
                    if (interactionMode === 'pan' || e.button === 1 || e.target === containerRef.current) {
                        setDragging({ type: 'viewport', startX: e.clientX, startY: e.clientY, initialX: viewport.x, initialY: viewport.y }); setSelectedId(null); e.target.setPointerCapture(e.pointerId); return;
                    }
                    setSelectedId(null);
                }
            };
            const handlePointerMove = (e) => {
                if (interactionMode === 'draw' && currentStroke) { const { x, y } = getCanvasCoordinates(e.clientX, e.clientY); setCurrentStroke(prev => [...prev, {x, y}]); return; }
                if (!dragging) return;
                if (dragging.type === 'viewport') { setViewport({ ...viewport, x: dragging.initialX + (e.clientX - dragging.startX), y: dragging.initialY + (e.clientY - dragging.startY) }); }
                else if (dragging.type === 'item') {
                    const deltaX = (e.clientX - dragging.startX) / viewport.scale; const deltaY = (e.clientY - dragging.startY) / viewport.scale;
                    setItems(prev => prev.map(item => item.id === dragging.id ? { ...item, x: dragging.initialItemX + deltaX, y: dragging.initialItemY + deltaY } : item));
                }
            };
            const handlePointerUp = (e) => {
                if (interactionMode === 'draw' && currentStroke) {
                    if (currentStroke.length > 2) {
                        const xs = currentStroke.map(p => p.x), ys = currentStroke.map(p => p.y);
                        const minX = Math.min(...xs), maxX = Math.max(...xs), minY = Math.min(...ys), maxY = Math.max(...ys);
                        const newItems = [...items, { id: Date.now(), type: 'drawing', x: minX, y: minY, width: Math.max(20, maxX - minX), height: Math.max(20, maxY - minY), points: currentStroke.map(p => ({ x: p.x - minX, y: p.y - minY })), color: '#1e293b' }];
                        setItems(newItems); pushToHistory(newItems, connections);
                        saveCanvasData(newItems, connections); 
                    }
                    setCurrentStroke(null);
                }
                if (dragging?.type === 'item') {
                    if (Math.abs(dragging.startX - e.clientX) > 5 || Math.abs(dragging.startY - e.clientY) > 5) {
                        pushToHistory(items, connections);
                        saveCanvasData(items, connections); 
                    }
                }
                setDragging(null);
                if (e.target && e.target.releasePointerCapture) e.target.releasePointerCapture(e.pointerId);
            };
            const handleTouchStart = (e) => { if (e.touches.length === 2) setPinchDistance(getTouchDistance(e.touches)); };
            const handleTouchMove = (e) => { if (e.touches.length === 2 && pinchDistance) { const dist = getTouchDistance(e.touches); const scaleFactor = dist / pinchDistance; const newScale = Math.min(Math.max(0.1, viewport.scale * scaleFactor), 3); setViewport(prev => ({...prev, scale: newScale})); setPinchDistance(dist); } };
            const handleTouchEnd = () => { setPinchDistance(null); };
            const handleItemPointerDown = (e, item) => {
                if (interactionMode === 'draw') return;
                if (interactionMode === 'connect') {
                    e.stopPropagation();
                    if (!connectStartId) setConnectStartId(item.id);
                    else {
                        if (connectStartId !== item.id) {
                            const newConn = { id: Date.now().toString(), from: connectStartId, to: item.id, type: 'solid' };
                            const newConns = [...connections, newConn]; setConnections(newConns); pushToHistory(items, newConns);
                            saveCanvasData(items, newConns); 
                        }
                        setConnectStartId(null); setInteractionMode('select');
                    }
                    return;
                }
                e.stopPropagation();
                setDragging({ type: 'item', id: item.id, startX: e.clientX, startY: e.clientY, initialItemX: item.x, initialItemY: item.y });
                setSelectedId(item.id);
                e.target.setPointerCapture(e.pointerId);
            };
            const handleWheel = (e) => {
                if (e.ctrlKey) { e.preventDefault(); const newScale = Math.min(Math.max(0.1, viewport.scale - e.deltaY * 0.001), 3); setViewport(prev => ({ ...prev, scale: newScale })); }
                else if (interactionMode === 'pan') { setViewport(prev => ({ ...prev, x: prev.x - e.deltaX, y: prev.y - e.deltaY })); }
            };

            const addItem = (type) => {
                const newItem = { id: Date.now(), type, x: (-viewport.x + window.innerWidth / 2) / viewport.scale - 100, y: (-viewport.y + window.innerHeight / 2) / viewport.scale - 50, width: type === 'note' ? 200 : 250, height: type === 'note' ? 200 : 160, title: type === 'task' ? 'งานใหม่' : '', content: '', color: type === 'task' ? 'bg-gray-500' : 'bg-yellow-200', status: 'todo' };
                const newItems = [...items, newItem]; setItems(newItems); setSelectedId(newItem.id); pushToHistory(newItems, connections);
                saveCanvasData(newItems, connections); 
            };
            const saveItem = (updated) => { 
                const newItems = items.map(i => i.id === updated.id ? updated : i); 
                setItems(newItems); 
                pushToHistory(newItems, connections); 
                saveCanvasData(newItems, connections); 
            };
            const deleteItem = (id) => { 
                const newItems = items.filter(i => i.id !== id); 
                const newConns = connections.filter(c => c.from !== id && c.to !== id); 
                setItems(newItems); setConnections(newConns); setSelectedId(null); 
                pushToHistory(newItems, newConns);
                saveCanvasData(newItems, newConns); 
            };

            if (authLoading) return <div className="h-screen w-full flex items-center justify-center bg-gray-50"><Loader2 className="w-8 h-8 animate-spin text-blue-600"/></div>;
            if (!user) return <AuthScreen />;

            if (view === 'dashboard') return <Dashboard user={user} notebooks={notebooks} selectedDate={selectedDate} onSelectDate={(date) => setSelectedDate(selectedDate?.getTime() === date?.getTime() ? null : date)} onSelectNotebook={(id) => setActiveNotebookId(id)} onCreateNotebook={handleCreateNotebook} onDeleteNotebook={handleDeleteNotebook} onRenameNotebook={handleRenameNotebook} onMigrate={handleMigrateData} hasLocalData={hasLocalData} />;

            return (
                <div className="w-full h-screen overflow-hidden bg-gray-50 text-slate-800 font-sans relative canvas-container">
                    <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur shadow-lg rounded-full px-4 py-2 z-50 flex items-center gap-2 sm:gap-4 border border-gray-200 max-w-[95vw] overflow-x-auto">
                        <button onClick={() => { setView('dashboard'); setActiveNotebookId(null); }} className="p-2 hover:bg-gray-100 rounded-full text-gray-600 mr-2 flex items-center gap-1"><ArrowLeft className="w-5 h-5" /><span className="text-sm font-medium hidden sm:inline">Back</span></button>
                        <div className="flex items-center gap-2 mr-2 border-r pr-4 border-gray-300"><Book className="w-5 h-5 text-blue-600" /><span className="font-bold text-gray-700 truncate max-w-[100px] sm:max-w-[150px]">{notebooks.find(n => n.id === activeNotebookId)?.name || 'Untitled'}</span></div>
                        <div className="flex items-center gap-1 mr-2 border-r pr-2 border-gray-300"><button onClick={undo} disabled={historyStep <= 0} className={`p-2 rounded-lg ${historyStep <= 0 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-100'}`}><Undo className="w-4 h-4" /></button><button onClick={redo} disabled={historyStep >= history.length - 1} className={`p-2 rounded-lg ${historyStep >= history.length - 1 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-100'}`}><Redo className="w-4 h-4" /></button></div>
                        <button onClick={() => addItem('task')} className="flex flex-col items-center group min-w-[40px]"><div className="p-2 rounded-lg group-hover:bg-blue-50 text-blue-600"><Plus className="w-6 h-6" /></div></button>
                        <button onClick={() => addItem('note')} className="flex flex-col items-center group min-w-[40px]"><div className="p-2 rounded-lg group-hover:bg-yellow-50 text-yellow-500"><StickyNote className="w-6 h-6" /></div></button>
                        <div className="h-6 w-px bg-gray-300 mx-1"></div>
                        <button onClick={() => setInteractionMode(interactionMode === 'draw' ? 'select' : 'draw')} className={`flex flex-col items-center group min-w-[40px] ${interactionMode === 'draw' ? 'text-purple-600' : 'text-gray-500'}`}><div className={`p-2 rounded-lg ${interactionMode === 'draw' ? 'bg-purple-100' : 'group-hover:bg-gray-100'}`}><PenTool className="w-6 h-6" /></div></button>
                        <div className="h-6 w-px bg-gray-300 mx-1"></div>
                        <button onClick={() => setInteractionMode(interactionMode === 'connect' ? 'select' : 'connect')} className={`flex flex-col items-center group min-w-[40px] ${interactionMode === 'connect' ? 'text-blue-600' : 'text-gray-500'}`}><div className={`p-2 rounded-lg ${interactionMode === 'connect' ? 'bg-blue-100' : 'group-hover:bg-gray-100'}`}><LinkIcon className="w-6 h-6" /></div></button>
                        <div className="h-6 w-px bg-gray-300 mx-1"></div>
                        <button onClick={() => setInteractionMode(interactionMode === 'pan' ? 'select' : 'pan')} className={`p-2 rounded-lg ${interactionMode === 'pan' ? 'bg-gray-200' : 'hover:bg-gray-100'}`}><Move className="w-5 h-5" /></button>
                    </div>
                    <div className="absolute bottom-6 left-6 bg-white shadow-md rounded-lg p-1 z-50 flex flex-col gap-1 border border-gray-200">
                        <button onClick={() => zoom(0.1)} className="p-2 hover:bg-gray-100"><ZoomIn className="w-5 h-5" /></button>
                        <button onClick={() => zoom(-0.1)} className="p-2 hover:bg-gray-100"><ZoomOut className="w-5 h-5" /></button>
                    </div>
                    {interactionMode === 'connect' && <div className="absolute top-24 left-1/2 transform -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg z-50 animate-bounce text-sm">{connectStartId ? "คลิกปลายทาง" : "คลิกต้นทาง"}</div>}
                    {interactionMode === 'draw' && <div className="absolute top-24 left-1/2 transform -translate-x-1/2 bg-purple-600 text-white px-4 py-2 rounded-full shadow-lg z-50 text-sm">วาดบนกระดานได้เลย</div>}
                    
                    <div 
                        ref={containerRef} 
                        className={`w-full h-full cursor-${interactionMode === 'pan' || dragging?.type === 'viewport' ? 'grab' : interactionMode === 'draw' ? 'crosshair' : 'default'}`} 
                        onPointerDown={handlePointerDown} 
                        onPointerMove={handlePointerMove} 
                        onPointerUp={handlePointerUp} 
                        onPointerCancel={handlePointerUp}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                        onWheel={handleWheel} 
                        style={{ backgroundImage: `radial-gradient(#cbd5e1 1px, transparent 1px)`, backgroundSize: `${20 * viewport.scale}px ${20 * viewport.scale}px`, backgroundPosition: `${viewport.x}px ${viewport.y}px` }}
                    >
                        <div style={{ transform: `translate(${viewport.x}px, ${viewport.y}px) scale(${viewport.scale})`, transformOrigin: '0 0', width: '100%', height: '100%' }} className="relative transition-transform duration-75 ease-out">
                            {currentStroke && <svg className="absolute top-0 left-0 w-full h-full pointer-events-none z-50 overflow-visible"><path d={getSvgPathFromStroke(currentStroke)} stroke="#000" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round" opacity="0.6" /></svg>}
                            <ConnectionLayer connections={connections} items={items} />
                            {items.map(item => (<CanvasItem key={item.id} item={item} isSelected={selectedId === item.id} onPointerDown={(e) => handleItemPointerDown(e, item)} onSelect={setSelectedId} onDoubleClick={setEditingItem} />))}
                        </div>
                    </div>
                    
                    <MiniMap items={items} viewport={viewport} setViewport={setViewport} />
                    <EditModal item={editingItem} isOpen={!!editingItem} onClose={() => setEditingItem(null)} onSave={saveItem} onDelete={deleteItem} />
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
